/* tslint:disable */
/* eslint-disable */
/**
 * Ergo Explorer API v1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AssetInfo
 */
export interface AssetInfo {
    /**
     * Header ID this asset belongs to
     * @type {string}
     * @memberof AssetInfo
     */
    'headerId': string;
    /**
     * Box ID this asset belongs to
     * @type {string}
     * @memberof AssetInfo
     */
    'boxId': string;
    /**
     * Token ID
     * @type {string}
     * @memberof AssetInfo
     */
    'tokenId': string;
    /**
     * Index of the asset in an output
     * @type {number}
     * @memberof AssetInfo
     */
    'index': number;
    /**
     * Amount of tokens
     * @type {number}
     * @memberof AssetInfo
     */
    'amount': number;
    /**
     * Name of the asset
     * @type {string}
     * @memberof AssetInfo
     */
    'name'?: string;
    /**
     * Number of decimal places
     * @type {number}
     * @memberof AssetInfo
     */
    'decimals'?: number;
    /**
     * Type of the asset (token standard)
     * @type {string}
     * @memberof AssetInfo
     */
    'type'?: string;
}
/**
 *
 * @export
 * @interface AssetInstanceInfo
 */

export type RegisterType = 'R4' | 'R5' | 'R6' | 'R7' | 'R8' | 'R9';

export interface RegisterDetail {
    serializedValue: string;
    sigmaType: string;
    renderedValue: string;
}

export type AdditionalRegisters = Partial<Record<RegisterType, RegisterDetail>>;
export interface AssetInstanceInfo {
    /**
     * Token ID
     * @type {string}
     * @memberof AssetInstanceInfo
     */
    'tokenId': string;
    /**
     * Index of the asset in an output
     * @type {number}
     * @memberof AssetInstanceInfo
     */
    'index': number;
    /**
     * Amount of tokens
     * @type {number}
     * @memberof AssetInstanceInfo
     */
    'amount': number;
    /**
     * Name of a token
     * @type {string}
     * @memberof AssetInstanceInfo
     */
    'name'?: string;
    /**
     * Number of decimal places
     * @type {number}
     * @memberof AssetInstanceInfo
     */
    'decimals'?: number;
    /**
     * Type of a token (token standard)
     * @type {string}
     * @memberof AssetInstanceInfo
     */
    'type'?: string;
}
/**
 *
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     *
     * @type {number}
     * @memberof BadRequest
     */
    'status': number;
    /**
     *
     * @type {string}
     * @memberof BadRequest
     */
    'reason': string;
}
/**
 *
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * Ergo balance
     * @type {number}
     * @memberof Balance
     */
    'nanoErgs': number;
    /**
     * Tokens balances
     * @type {Array<TokenAmount>}
     * @memberof Balance
     */
    'tokens'?: Array<TokenAmount>;
}
/**
 *
 * @export
 * @interface BlockExtensionInfo
 */
export interface BlockExtensionInfo {
    /**
     * ID of the corresponding header
     * @type {string}
     * @memberof BlockExtensionInfo
     */
    'headerId': string;
    /**
     * Hex-encoded extension digest
     * @type {string}
     * @memberof BlockExtensionInfo
     */
    'digest': string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof BlockExtensionInfo
     */
    'fields': { [key: string]: string; };
}
/**
 *
 * @export
 * @interface BlockHeader
 */
export interface BlockHeader {
    /**
     * Modifier ID
     * @type {string}
     * @memberof BlockHeader
     */
    'id': string;
    /**
     * Modifier ID
     * @type {string}
     * @memberof BlockHeader
     */
    'parentId': string;
    /**
     *
     * @type {number}
     * @memberof BlockHeader
     */
    'version': number;
    /**
     *
     * @type {number}
     * @memberof BlockHeader
     */
    'timestamp': number;
    /**
     *
     * @type {number}
     * @memberof BlockHeader
     */
    'height': number;
    /**
     *
     * @type {number}
     * @memberof BlockHeader
     */
    'nBits': number;
    /**
     *
     * @type {string}
     * @memberof BlockHeader
     */
    'votes': string;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof BlockHeader
     */
    'stateRoot': string;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof BlockHeader
     */
    'adProofsRoot': string;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof BlockHeader
     */
    'transactionsRoot': string;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof BlockHeader
     */
    'extensionHash': string;
    /**
     *
     * @type {BlockPowSolutions}
     * @memberof BlockHeader
     */
    'powSolutions': BlockPowSolutions;
}

export interface BlocksInfo {
    'items': Array<BlockInfo>
}

/**
 *
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
    /**
     * Block ID
     * @type {string}
     * @memberof BlockInfo
     */
    'id': string;
    /**
     * Block height
     * @type {number}
     * @memberof BlockInfo
     */
    'height': number;
    /**
     * Block epoch (Epochs are enumerated from 0)
     * @type {number}
     * @memberof BlockInfo
     */
    'epoch': number;
    /**
     * Block version
     * @type {number}
     * @memberof BlockInfo
     */
    'version': number;
    /**
     * Timestamp the block was created (UNIX timestamp in millis)
     * @type {number}
     * @memberof BlockInfo
     */
    'timestamp': number;
    /**
     * Number of transactions included in the block
     * @type {number}
     * @memberof BlockInfo
     */
    'transactionsCount': number;
    /**
     *
     * @type {MinerInfo}
     * @memberof BlockInfo
     */
    'miner': MinerInfo;
    /**
     * Overall size of the block in bytes
     * @type {number}
     * @memberof BlockInfo
     */
    'size': number;
    /**
     * Block difficulty
     * @type {string}
     * @memberof BlockInfo
     */
    'difficulty': string;
    /**
     * The amount of nanoErgs miner received as a reward for block
     * @type {number}
     * @memberof BlockInfo
     */
    'minerReward': number;
}
/**
 *
 * @export
 * @interface BlockPowSolutions
 */
export interface BlockPowSolutions {
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof BlockPowSolutions
     */
    'pk': string;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof BlockPowSolutions
     */
    'w': string;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof BlockPowSolutions
     */
    'n': string;
    /**
     *
     * @type {string}
     * @memberof BlockPowSolutions
     */
    'd': string;
}
/**
 * References to previous and next (if exists) blocks
 * @export
 * @interface BlockReferencesInfo
 */
export interface BlockReferencesInfo {
    /**
     * ID of the previous block
     * @type {string}
     * @memberof BlockReferencesInfo
     */
    'previousId': string;
    /**
     * ID of the next block (if one exists)
     * @type {string}
     * @memberof BlockReferencesInfo
     */
    'nextId'?: string;
}
/**
 *
 * @export
 * @interface BlockSummary
 */
export interface BlockSummary {
    /**
     *
     * @type {FullBlockInfo}
     * @memberof BlockSummary
     */
    'block': FullBlockInfo;
    /**
     *
     * @type {BlockReferencesInfo}
     * @memberof BlockSummary
     */
    'references': BlockReferencesInfo;
}
/**
 *
 * @export
 * @interface BlockSummaryV1
 */
export interface BlockSummaryV1 {
    /**
     *
     * @type {HeaderInfo}
     * @memberof BlockSummaryV1
     */
    'header': HeaderInfo;
    /**
     *
     * @type {Array<TransactionInfo1>}
     * @memberof BlockSummaryV1
     */
    'blockTransactions'?: Array<TransactionInfo1>;
}
/**
 *
 * @export
 * @interface BoxAssetsQuery
 */
export interface BoxAssetsQuery {
    /**
     * SHA-256 hash of ErgoTree template this box script should have
     * @type {string}
     * @memberof BoxAssetsQuery
     */
    'ergoTreeTemplateHash': string;
    /**
     * IDs of tokens returned boxes should contain
     * @type {Array<string>}
     * @memberof BoxAssetsQuery
     */
    'assets'?: Array<string>;
}
/**
 *
 * @export
 * @interface BoxQuery
 */
export interface BoxQuery {
    /**
     * SHA-256 hash of ErgoTree template this box script should have
     * @type {string}
     * @memberof BoxQuery
     */
    'ergoTreeTemplateHash': string;
    /**
     * Pairs of (register ID, register value) this box should contain
     * @type {{ [key: string]: string; }}
     * @memberof BoxQuery
     */
    'registers'?: { [key: string]: string; };
    /**
     * Pairs of (constant index, constant value) this box should contain
     * @type {{ [key: string]: string; }}
     * @memberof BoxQuery
     */
    'constants'?: { [key: string]: string; };
    /**
     * IDs of tokens returned boxes should contain
     * @type {Array<string>}
     * @memberof BoxQuery
     */
    'assets'?: Array<string>;
}
/**
 *
 * @export
 * @interface DataInputInfo
 */
export interface DataInputInfo {
    /**
     * ID of the corresponding box
     * @type {string}
     * @memberof DataInputInfo
     */
    'boxId': string;
    /**
     * Number of nanoErgs in the corresponding box
     * @type {number}
     * @memberof DataInputInfo
     */
    'value': number;
    /**
     * Index of the input in a transaction
     * @type {number}
     * @memberof DataInputInfo
     */
    'index': number;
    /**
     * Modifier ID
     * @type {string}
     * @memberof DataInputInfo
     */
    'outputBlockId': string;
    /**
     * ID of the transaction outputting corresponding box
     * @type {string}
     * @memberof DataInputInfo
     */
    'outputTransactionId': string;
    /**
     * Index of the output corresponding this input
     * @type {number}
     * @memberof DataInputInfo
     */
    'outputIndex': number;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof DataInputInfo
     */
    'ergoTree': string;
    /**
     * Decoded address of the corresponding box holder
     * @type {string}
     * @memberof DataInputInfo
     */
    'address': string;
    /**
     *
     * @type {Array<AssetInstanceInfo>}
     * @memberof DataInputInfo
     */
    'assets'?: Array<AssetInstanceInfo>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof DataInputInfo
     */
    'additionalRegisters': { [key: string]: string; };
}
/**
 *
 * @export
 * @interface DataInputInfo1
 */
export interface DataInputInfo1 {
    /**
     * ID of the corresponding box
     * @type {string}
     * @memberof DataInputInfo1
     */
    'id': string;
    /**
     * Number of nanoErgs in the corresponding box
     * @type {number}
     * @memberof DataInputInfo1
     */
    'value'?: number;
    /**
     *
     * @type {number}
     * @memberof DataInputInfo1
     */
    'index': number;
    /**
     * ID of the transaction this data input was used in
     * @type {string}
     * @memberof DataInputInfo1
     */
    'transactionId': string;
    /**
     * ID of the transaction outputting corresponding box
     * @type {string}
     * @memberof DataInputInfo1
     */
    'outputTransactionId'?: string;
    /**
     *
     * @type {number}
     * @memberof DataInputInfo1
     */
    'outputIndex'?: number;
    /**
     * Decoded address of the corresponding box holder
     * @type {string}
     * @memberof DataInputInfo1
     */
    'address'?: string;
}
/**
 *
 * @export
 * @interface EpochInfo
 */
export interface EpochInfo {
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'height': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'storageFeeFactor': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'minValuePerByte': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'maxBlockSize': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'maxBlockCost': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'blockVersion': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'tokenAccessCost': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'inputCost': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'dataInputCost': number;
    /**
     *
     * @type {number}
     * @memberof EpochInfo
     */
    'outputCost': number;
}
/**
 *
 * @export
 * @interface ErgoTreeConversionRequest
 */
export interface ErgoTreeConversionRequest {
    /**
     * Hashed value of ergo script
     * @type {string}
     * @memberof ErgoTreeConversionRequest
     */
    'hashed': string;
}
/**
 *
 * @export
 * @interface ErgoTreeHuman
 */
export interface ErgoTreeHuman {
    /**
     * Constants use in ergo script
     * @type {string}
     * @memberof ErgoTreeHuman
     */
    'constants': string;
    /**
     * Human readable ergo script
     * @type {string}
     * @memberof ErgoTreeHuman
     */
    'script': string;
}
/**
 * Full block info
 * @export
 * @interface FullBlockInfo
 */
export interface FullBlockInfo {
    /**
     *
     * @type {HeaderInfo}
     * @memberof FullBlockInfo
     */
    'header': HeaderInfo;
    /**
     *
     * @type {Array<TransactionInfo1>}
     * @memberof FullBlockInfo
     */
    'blockTransactions'?: Array<TransactionInfo1>;
    /**
     *
     * @type {BlockExtensionInfo}
     * @memberof FullBlockInfo
     */
    'extension': BlockExtensionInfo;
    /**
     * Serialized hex-encoded AD Proofs
     * @type {string}
     * @memberof FullBlockInfo
     */
    'adProofs'?: string;
}
/**
 *
 * @export
 * @interface HeaderInfo
 */
export interface HeaderInfo {
    /**
     * Block/header ID
     * @type {string}
     * @memberof HeaderInfo
     */
    'id': string;
    /**
     * ID of the parental block/header
     * @type {string}
     * @memberof HeaderInfo
     */
    'parentId': string;
    /**
     * Version of the header
     * @type {number}
     * @memberof HeaderInfo
     */
    'version': number;
    /**
     * Block/header height
     * @type {number}
     * @memberof HeaderInfo
     */
    'height': number;
    /**
     * Block/header epoch (Epochs are enumerated from 0)
     * @type {number}
     * @memberof HeaderInfo
     */
    'epoch': number;
    /**
     * Block/header difficulty
     * @type {string}
     * @memberof HeaderInfo
     */
    'difficulty': string;
    /**
     * Hex-encoded root of the corresponding AD proofs
     * @type {string}
     * @memberof HeaderInfo
     */
    'adProofsRoot': string;
    /**
     * Hex-encoded root of the corresponding state
     * @type {string}
     * @memberof HeaderInfo
     */
    'stateRoot': string;
    /**
     * Hex-encoded root of the corresponding transactions
     * @type {string}
     * @memberof HeaderInfo
     */
    'transactionsRoot': string;
    /**
     * Timestamp the block/header was created
     * @type {number}
     * @memberof HeaderInfo
     */
    'timestamp': number;
    /**
     * Encoded required difficulty
     * @type {number}
     * @memberof HeaderInfo
     */
    'nBits': number;
    /**
     * Size of the header in bytes
     * @type {number}
     * @memberof HeaderInfo
     */
    'size': number;
    /**
     * Hex-encoded hash of the corresponding extension
     * @type {string}
     * @memberof HeaderInfo
     */
    'extensionHash': string;
    /**
     *
     * @type {PowSolutionInfo}
     * @memberof HeaderInfo
     */
    'powSolutions': PowSolutionInfo;
    /**
     *
     * @type {Tuple3ByteByteByte}
     * @memberof HeaderInfo
     */
    'votes': Tuple3ByteByteByte;
}
/**
 *
 * @export
 * @interface InputInfo
 */
export interface InputInfo {
    /**
     * ID of the corresponding box
     * @type {string}
     * @memberof InputInfo
     */
    'boxId': string;
    /**
     * Number of nanoErgs in the corresponding box
     * @type {number}
     * @memberof InputInfo
     */
    'value': number;
    /**
     * Index of the input in a transaction
     * @type {number}
     * @memberof InputInfo
     */
    'index': number;
    /**
     * Hex-encoded serialized sigma proof
     * @type {string}
     * @memberof InputInfo
     */
    'spendingProof'?: string;
    /**
     * Modifier ID
     * @type {string}
     * @memberof InputInfo
     */
    'outputBlockId': string;
    /**
     * ID of the transaction outputting corresponding box
     * @type {string}
     * @memberof InputInfo
     */
    'outputTransactionId': string;
    /**
     * Index of the output corresponding this input
     * @type {number}
     * @memberof InputInfo
     */
    'outputIndex': number;
    /**
     * Global index of the output corresponding this input
     * @type {number}
     * @memberof InputInfo
     */
    'outputGlobalIndex': number;
    /**
     * Height the output corresponding this input was created at
     * @type {number}
     * @memberof InputInfo
     */
    'outputCreatedAt': number;
    /**
     * Height the output corresponding this input was settled at
     * @type {number}
     * @memberof InputInfo
     */
    'outputSettledAt': number;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof InputInfo
     */
    'ergoTree': string;
    /**
     *
     * @type {string}
     * @memberof InputInfo
     */
    'ergoTreeConstants': string;
    /**
     *
     * @type {string}
     * @memberof InputInfo
     */
    'ergoTreeScript': string;
    /**
     * Decoded address of the corresponding box holder
     * @type {string}
     * @memberof InputInfo
     */
    'address': string;
    /**
     *
     * @type {Array<AssetInstanceInfo>}
     * @memberof InputInfo
     */
    'assets'?: Array<AssetInstanceInfo>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof InputInfo
     */
    'additionalRegisters': { [key: string]: string; };
}
/**
 *
 * @export
 * @interface InputInfo1
 */
export interface InputInfo1 {
    /**
     * ID of the corresponding box
     * @type {string}
     * @memberof InputInfo1
     */
    'id': string;
    /**
     * Number of nanoErgs in the corresponding box
     * @type {number}
     * @memberof InputInfo1
     */
    'value'?: number;
    /**
     * Index of the input in a transaction
     * @type {number}
     * @memberof InputInfo1
     */
    'index': number;
    /**
     * Hex-encoded serialized sigma proof
     * @type {string}
     * @memberof InputInfo1
     */
    'spendingProof'?: string;
    /**
     * ID of the transaction this input was used in
     * @type {string}
     * @memberof InputInfo1
     */
    'transactionId': string;
    /**
     * ID of the transaction outputting corresponding box
     * @type {string}
     * @memberof InputInfo1
     */
    'outputTransactionId'?: string;
    /**
     * Index of the output corresponding this input
     * @type {number}
     * @memberof InputInfo1
     */
    'outputIndex'?: number;
    /**
     * Decoded address of the corresponding box holder
     * @type {string}
     * @memberof InputInfo1
     */
    'address'?: string;
}
/**
 *
 * @export
 * @interface ItemsA
 */
export interface ItemsA {
    /**
     * Items in selection
     * @type {Array<TransactionInfo>}
     * @memberof ItemsA
     */
    'items'?: Array<TransactionInfo>;
    /**
     * Total qty of items
     * @type {number}
     * @memberof ItemsA
     */
    'total': number;
}

export interface ItemsB {
    /**
     * Items in selection
     * @type {Array<TransactionInfo>}
     * @memberof ItemsA
     */
    'items'?: Array<OutputInfo>;
    /**
     * Total qty of items
     * @type {number}
     * @memberof ItemsA
     */
    'total': number;
}

/**
 * @type ListBlockInfo
 * @export
 */
export type ListBlockInfo = Array<BlockInfo> | object;

/**
 * @type ListBlockSummaryV1
 * @export
 */
export type ListBlockSummaryV1 = Array<BlockSummaryV1> | object;

/**
 * @type ListOutputInfo
 * @export
 */
export type ListOutputInfo = Array<OutputInfo> | object;

/**
 * @type ListTransactionInfo
 * @export
 */
export type ListTransactionInfo = Array<TransactionInfo> | object;

/**
 *
 * @export
 * @interface MOutputInfo
 */
export interface MOutputInfo {
    /**
     * Id of the box
     * @type {string}
     * @memberof MOutputInfo
     */
    'boxId': string;
    /**
     * Id of the transaction that created the box
     * @type {string}
     * @memberof MOutputInfo
     */
    'transactionId': string;
    /**
     * Id of the block a box included in
     * @type {string}
     * @memberof MOutputInfo
     */
    'blockId'?: string;
    /**
     * Value of the box in nanoERG
     * @type {number}
     * @memberof MOutputInfo
     */
    'value': number;
    /**
     * Index of the output in a transaction
     * @type {number}
     * @memberof MOutputInfo
     */
    'index': number;
    /**
     * Global index of the output in the blockchain
     * @type {number}
     * @memberof MOutputInfo
     */
    'globalIndex'?: number;
    /**
     * Height at which the box was created
     * @type {number}
     * @memberof MOutputInfo
     */
    'creationHeight': number;
    /**
     * Height at which the box got fixed in blockchain
     * @type {number}
     * @memberof MOutputInfo
     */
    'settlementHeight'?: number;
    /**
     * Serialized ergo tree
     * @type {string}
     * @memberof MOutputInfo
     */
    'ergoTree': string;
    /**
     * An address derived from ergo tree
     * @type {string}
     * @memberof MOutputInfo
     */
    'address': string;
    /**
     *
     * @type {Array<AssetInstanceInfo>}
     * @memberof MOutputInfo
     */
    'assets'?: Array<AssetInstanceInfo>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof MOutputInfo
     */
    'additionalRegisters': AdditionalRegisters;
    /**
     * Id of the transaction this output was spent by
     * @type {string}
     * @memberof MOutputInfo
     */
    'spentTransactionId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof MOutputInfo
     */
    'mainChain': boolean;
}
/**
 *
 * @export
 * @interface MinerInfo
 */
export interface MinerInfo {
    /**
     * Miner reward address
     * @type {string}
     * @memberof MinerInfo
     */
    'address': string;
    /**
     * Miner name
     * @type {string}
     * @memberof MinerInfo
     */
    'name': string;
}
/**
 *
 * @export
 * @interface NetworkState
 */
export interface NetworkState {
    /**
     * Modifier ID
     * @type {string}
     * @memberof NetworkState
     */
    'lastBlockId': string;
    /**
     *
     * @type {number}
     * @memberof NetworkState
     */
    'height': number;
    /**
     *
     * @type {number}
     * @memberof NetworkState
     */
    'maxBoxGix': number;
    /**
     *
     * @type {number}
     * @memberof NetworkState
     */
    'maxTxGix': number;
    /**
     *
     * @type {EpochInfo}
     * @memberof NetworkState
     */
    'params': EpochInfo;
}
/**
 *
 * @export
 * @interface NetworkStats
 */
export interface NetworkStats {
    /**
     *
     * @type {number}
     * @memberof NetworkStats
     */
    'uniqueAddressesNum': number;
}
/**
 *
 * @export
 * @interface NotFound
 */
export interface NotFound {
    /**
     *
     * @type {number}
     * @memberof NotFound
     */
    'status': number;
    /**
     *
     * @type {string}
     * @memberof NotFound
     */
    'reason': string;
}
/**
 *
 * @export
 * @interface OutputInfo
 */
export interface OutputInfo {
    /**
     * Id of the box
     * @type {string}
     * @memberof OutputInfo
     */
    'boxId': string;
    /**
     * Id of the transaction that created the box
     * @type {string}
     * @memberof OutputInfo
     */
    'transactionId': string;
    /**
     * Id of the block a box included in
     * @type {string}
     * @memberof OutputInfo
     */
    'blockId': string;
    /**
     * Value of the box in nanoERG
     * @type {number}
     * @memberof OutputInfo
     */
    'value': number;
    /**
     * Index of the output in a transaction
     * @type {number}
     * @memberof OutputInfo
     */
    'index': number;
    /**
     * Global index of the output in the blockchain
     * @type {number}
     * @memberof OutputInfo
     */
    'globalIndex': number;
    /**
     * Height at which the box was created
     * @type {number}
     * @memberof OutputInfo
     */
    'creationHeight': number;
    /**
     * Height at which the box got fixed in blockchain
     * @type {number}
     * @memberof OutputInfo
     */
    'settlementHeight': number;
    /**
     * Serialized ergo tree
     * @type {string}
     * @memberof OutputInfo
     */
    'ergoTree': string;
    /**
     *
     * @type {string}
     * @memberof OutputInfo
     */
    'ergoTreeConstants': string;
    /**
     *
     * @type {string}
     * @memberof OutputInfo
     */
    'ergoTreeScript': string;
    /**
     * An address derived from ergo tree
     * @type {string}
     * @memberof OutputInfo
     */
    'address': string;
    /**
     *
     * @type {Array<AssetInstanceInfo>}
     * @memberof OutputInfo
     */
    'assets'?: Array<AssetInstanceInfo>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof OutputInfo
     */
    'additionalRegisters': AdditionalRegisters;
    /**
     * Id of the transaction this output was spent by
     * @type {string}
     * @memberof OutputInfo
     */
    'spentTransactionId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof OutputInfo
     */
    'mainChain': boolean;
}
/**
 *
 * @export
 * @interface OutputInfo1
 */
export interface OutputInfo1 {
    /**
     * Id of the box
     * @type {string}
     * @memberof OutputInfo1
     */
    'id': string;
    /**
     * Id of the transaction that created the box
     * @type {string}
     * @memberof OutputInfo1
     */
    'txId': string;
    /**
     * Value of the box in nanoERG
     * @type {number}
     * @memberof OutputInfo1
     */
    'value': number;
    /**
     * Index of the output in a transaction
     * @type {number}
     * @memberof OutputInfo1
     */
    'index': number;
    /**
     * Height at which the box was created
     * @type {number}
     * @memberof OutputInfo1
     */
    'creationHeight': number;
    /**
     * Serialized ergo tree
     * @type {string}
     * @memberof OutputInfo1
     */
    'ergoTree': string;
    /**
     * An address derived from ergo tree
     * @type {string}
     * @memberof OutputInfo1
     */
    'address': string;
    /**
     *
     * @type {Array<AssetInstanceInfo>}
     * @memberof OutputInfo1
     */
    'assets'?: Array<AssetInstanceInfo>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof OutputInfo1
     */
    'additionalRegisters': { [key: string]: string; };
    /**
     * Transaction ID
     * @type {string}
     * @memberof OutputInfo1
     */
    'spentTransactionId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof OutputInfo1
     */
    'mainChain': boolean;
}
/**
 *
 * @export
 * @interface PowSolutionInfo
 */
export interface PowSolutionInfo {
    /**
     * Miner public key
     * @type {string}
     * @memberof PowSolutionInfo
     */
    'pk': string;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof PowSolutionInfo
     */
    'w': string;
    /**
     * Hex-encoded string
     * @type {string}
     * @memberof PowSolutionInfo
     */
    'n': string;
    /**
     * Autolykos.d
     * @type {string}
     * @memberof PowSolutionInfo
     */
    'd': string;
}
/**
 *
 * @export
 * @interface TokenAmount
 */
export interface TokenAmount {
    /**
     * Token ID
     * @type {string}
     * @memberof TokenAmount
     */
    'tokenId': string;
    /**
     * Token amount
     * @type {number}
     * @memberof TokenAmount
     */
    'amount': number;
    /**
     * Number of decimals
     * @type {number}
     * @memberof TokenAmount
     */
    'decimals': number;
    /**
     * Token name
     * @type {string}
     * @memberof TokenAmount
     */
    'name'?: string;
    /**
     * Asset type (token standard)
     * @type {string}
     * @memberof TokenAmount
     */
    'tokenType'?: string;
}
/**
 *
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
    /**
     * ID of the asset
     * @type {string}
     * @memberof TokenInfo
     */
    'id': string;
    /**
     * Box ID this asset was issued by
     * @type {string}
     * @memberof TokenInfo
     */
    'boxId': string;
    /**
     * Number of decimal places
     * @type {number}
     * @memberof TokenInfo
     */
    'emissionAmount': number;
    /**
     * Name of the asset
     * @type {string}
     * @memberof TokenInfo
     */
    'name'?: string;
    /**
     * Description of the asset
     * @type {string}
     * @memberof TokenInfo
     */
    'description'?: string;
    /**
     * Asset type (token standard)
     * @type {string}
     * @memberof TokenInfo
     */
    'type'?: string;
    /**
     * Number of decimal places
     * @type {number}
     * @memberof TokenInfo
     */
    'decimals'?: number;
}
/**
 *
 * @export
 * @interface TotalBalance
 */
export interface TotalBalance {
    /**
     *
     * @type {Balance}
     * @memberof TotalBalance
     */
    'confirmed': Balance;
    /**
     *
     * @type {Balance}
     * @memberof TotalBalance
     */
    'unconfirmed': Balance;
}
/**
 *
 * @export
 * @interface TransactionInfo
 */
export interface TransactionInfo {
    /**
     * Transaction ID
     * @type {string}
     * @memberof TransactionInfo
     */
    'id': string;
    /**
     * ID of the corresponding header
     * @type {string}
     * @memberof TransactionInfo
     */
    'blockId': string;
    /**
     * Height of the block the transaction was included in
     * @type {number}
     * @memberof TransactionInfo
     */
    'inclusionHeight': number;
    /**
     * Timestamp the transaction got into the network
     * @type {number}
     * @memberof TransactionInfo
     */
    'timestamp': number;
    /**
     * Index of a transaction inside a block
     * @type {number}
     * @memberof TransactionInfo
     */
    'index': number;
    /**
     * global index of a transaction in the blockchain
     * @type {number}
     * @memberof TransactionInfo
     */
    'globalIndex': number;
    /**
     * Number of transaction confirmations
     * @type {number}
     * @memberof TransactionInfo
     */
    'numConfirmations': number;
    /**
     *
     * @type {Array<InputInfo>}
     * @memberof TransactionInfo
     */
    'inputs'?: Array<InputInfo>;
    /**
     *
     * @type {Array<DataInputInfo>}
     * @memberof TransactionInfo
     */
    'dataInputs'?: Array<DataInputInfo>;
    /**
     *
     * @type {Array<OutputInfo>}
     * @memberof TransactionInfo
     */
    'outputs'?: Array<OutputInfo>;
    /**
     * Transaction size in bytes
     * @type {number}
     * @memberof TransactionInfo
     */
    'size': number;
}
/**
 *
 * @export
 * @interface TransactionInfo1
 */
export interface TransactionInfo1 {
    /**
     * Transaction ID
     * @type {string}
     * @memberof TransactionInfo1
     */
    'id': string;
    /**
     * ID of the corresponding header
     * @type {string}
     * @memberof TransactionInfo1
     */
    'headerId': string;
    /**
     * Height of the block the transaction was included in
     * @type {number}
     * @memberof TransactionInfo1
     */
    'inclusionHeight': number;
    /**
     * Timestamp the transaction got into the network
     * @type {number}
     * @memberof TransactionInfo1
     */
    'timestamp': number;
    /**
     * Index of a transaction inside a block
     * @type {number}
     * @memberof TransactionInfo1
     */
    'index': number;
    /**
     * Number of transaction confirmations
     * @type {number}
     * @memberof TransactionInfo1
     */
    'confirmationsCount': number;
    /**
     *
     * @type {Array<InputInfo1>}
     * @memberof TransactionInfo1
     */
    'inputs'?: Array<InputInfo1>;
    /**
     *
     * @type {Array<DataInputInfo1>}
     * @memberof TransactionInfo1
     */
    'dataInputs'?: Array<DataInputInfo1>;
    /**
     *
     * @type {Array<OutputInfo1>}
     * @memberof TransactionInfo1
     */
    'outputs'?: Array<OutputInfo1>;
}
/**
 * Block votes (3 bytes)
 * @export
 * @interface Tuple3ByteByteByte
 */
export interface Tuple3ByteByteByte {
    /**
     *
     * @type {number}
     * @memberof Tuple3ByteByteByte
     */
    '_1': number;
    /**
     *
     * @type {number}
     * @memberof Tuple3ByteByteByte
     */
    '_2': number;
    /**
     *
     * @type {number}
     * @memberof Tuple3ByteByteByte
     */
    '_3': number;
}
/**
 *
 * @export
 * @interface TxIdResponse
 */
export interface TxIdResponse {
    /**
     * Id of submitted transaction
     * @type {string}
     * @memberof TxIdResponse
     */
    'id': string;
}
/**
 *
 * @export
 * @interface UDataInputInfo
 */
export interface UDataInputInfo {
    /**
     * ID of the corresponding box
     * @type {string}
     * @memberof UDataInputInfo
     */
    'boxId': string;
    /**
     * Number of nanoErgs in the corresponding box
     * @type {number}
     * @memberof UDataInputInfo
     */
    'value': number;
    /**
     * Index of the input in a transaction
     * @type {number}
     * @memberof UDataInputInfo
     */
    'index': number;
    /**
     * Modifier ID
     * @type {string}
     * @memberof UDataInputInfo
     */
    'outputBlockId'?: string;
    /**
     * ID of the transaction outputting corresponding box
     * @type {string}
     * @memberof UDataInputInfo
     */
    'outputTransactionId': string;
    /**
     * Index of the output corresponding this input
     * @type {number}
     * @memberof UDataInputInfo
     */
    'outputIndex': number;
    /**
     * ErgoTree Template
     * @type {string}
     * @memberof UDataInputInfo
     */
    'ergoTree': string;
    /**
     * Decoded address of the corresponding box holder
     * @type {string}
     * @memberof UDataInputInfo
     */
    'address': string;
    /**
     *
     * @type {Array<AssetInstanceInfo>}
     * @memberof UDataInputInfo
     */
    'assets'?: Array<AssetInstanceInfo>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof UDataInputInfo
     */
    'additionalRegisters': { [key: string]: string; };
}
/**
 *
 * @export
 * @interface UInputInfo
 */
export interface UInputInfo {
    /**
     * ID of the corresponding box
     * @type {string}
     * @memberof UInputInfo
     */
    'boxId': string;
    /**
     * Number of nanoErgs in the corresponding box
     * @type {number}
     * @memberof UInputInfo
     */
    'value': number;
    /**
     * Index of the input in a transaction
     * @type {number}
     * @memberof UInputInfo
     */
    'index': number;
    /**
     * Hex-encoded serialized sigma proof
     * @type {string}
     * @memberof UInputInfo
     */
    'spendingProof'?: string;
    /**
     * Modifier ID
     * @type {string}
     * @memberof UInputInfo
     */
    'outputBlockId'?: string;
    /**
     * ID of the transaction outputting corresponding box
     * @type {string}
     * @memberof UInputInfo
     */
    'outputTransactionId': string;
    /**
     * Index of the output corresponding this input
     * @type {number}
     * @memberof UInputInfo
     */
    'outputIndex': number;
    /**
     * ErgoTree Template
     * @type {string}
     * @memberof UInputInfo
     */
    'ergoTree': string;
    /**
     * Decoded address of the corresponding box holder
     * @type {string}
     * @memberof UInputInfo
     */
    'address': string;
    /**
     *
     * @type {Array<AssetInstanceInfo>}
     * @memberof UInputInfo
     */
    'assets'?: Array<AssetInstanceInfo>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof UInputInfo
     */
    'additionalRegisters': { [key: string]: string; };
}
/**
 *
 * @export
 * @interface UOutputInfo
 */
export interface UOutputInfo {
    /**
     * Id of the box
     * @type {string}
     * @memberof UOutputInfo
     */
    'boxId': string;
    /**
     * Id of the transaction that created the box
     * @type {string}
     * @memberof UOutputInfo
     */
    'transactionId': string;
    /**
     * Value of the box in nanoERG
     * @type {number}
     * @memberof UOutputInfo
     */
    'value': number;
    /**
     * Index of the output in a transaction
     * @type {number}
     * @memberof UOutputInfo
     */
    'index': number;
    /**
     * Height at which the box was created
     * @type {number}
     * @memberof UOutputInfo
     */
    'creationHeight': number;
    /**
     * Serialized ergo tree
     * @type {string}
     * @memberof UOutputInfo
     */
    'ergoTree': string;
    /**
     * An address derived from ergo tree
     * @type {string}
     * @memberof UOutputInfo
     */
    'address': string;
    /**
     *
     * @type {Array<AssetInstanceInfo>}
     * @memberof UOutputInfo
     */
    'assets'?: Array<AssetInstanceInfo>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof UOutputInfo
     */
    'additionalRegisters': { [key: string]: string; };
    /**
     * Id of the transaction this output was spent by
     * @type {string}
     * @memberof UOutputInfo
     */
    'spentTransactionId'?: string;
}
/**
 *
 * @export
 * @interface UTransactionInfo
 */
export interface UTransactionInfo {
    /**
     * Transaction ID
     * @type {string}
     * @memberof UTransactionInfo
     */
    'id': string;
    /**
     * Timestamp the transaction got into the network
     * @type {number}
     * @memberof UTransactionInfo
     */
    'creationTimestamp': number;
    /**
     *
     * @type {Array<UInputInfo>}
     * @memberof UTransactionInfo
     */
    'inputs'?: Array<UInputInfo>;
    /**
     *
     * @type {Array<UDataInputInfo>}
     * @memberof UTransactionInfo
     */
    'dataInputs'?: Array<UDataInputInfo>;
    /**
     *
     * @type {Array<UOutputInfo>}
     * @memberof UTransactionInfo
     */
    'outputs'?: Array<UOutputInfo>;
    /**
     * Transaction size in bytes
     * @type {number}
     * @memberof UTransactionInfo
     */
    'size': number;
}
/**
 *
 * @export
 * @interface UnknownErr
 */
export interface UnknownErr {
    /**
     *
     * @type {number}
     * @memberof UnknownErr
     */
    'status': number;
    /**
     *
     * @type {string}
     * @memberof UnknownErr
     */
    'reason': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} p1
         * @param {number} [minConfirmations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1AddressesP1BalanceConfirmed: async (p1: string, minConfirmations?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1AddressesP1BalanceConfirmed', 'p1', p1)
            const localVarPath = `/api/v1/addresses/{p1}/balance/confirmed`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minConfirmations !== undefined) {
                localVarQueryParameter['minConfirmations'] = minConfirmations;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1AddressesP1BalanceTotal: async (p1: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1AddressesP1BalanceTotal', 'p1', p1)
            const localVarPath = `/api/v1/addresses/{p1}/balance/total`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [concise] Display only address inputs/outputs in transaction
         * @param {number} [fromHeight]
         * @param {number} [toHeight]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1AddressesP1Transactions: async (p1: string, offset?: number, limit?: number, concise?: boolean, fromHeight?: number, toHeight?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1AddressesP1Transactions', 'p1', p1)
            const localVarPath = `/api/v1/addresses/{p1}/transactions`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (concise !== undefined) {
                localVarQueryParameter['concise'] = concise;
            }

            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }

            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use \'/tokens\' instead
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {boolean} [hideNfts] Exclude NFTs from result set
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getApiV1Assets: async (offset?: number, limit?: number, sortDirection?: string, hideNfts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (hideNfts !== undefined) {
                localVarQueryParameter['hideNfts'] = hideNfts;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} query
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1AssetsSearchBytokenid: async (query: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getApiV1AssetsSearchBytokenid', 'query', query)
            const localVarPath = `/api/v1/assets/search/byTokenId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1Blocks: async (offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a stream of blocks ordered by global index (height)
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BlocksByglobalindexStream: async (minGix: number, limit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'minGix' is not null or undefined
            assertParamExists('getApiV1BlocksByglobalindexStream', 'minGix', minGix)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getApiV1BlocksByglobalindexStream', 'limit', limit)
            const localVarPath = `/api/v1/blocks/byGlobalIndex/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minGix !== undefined) {
                localVarQueryParameter['minGix'] = minGix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BlocksHeaders: async (offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/blocks/headers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BlocksP1: async (p1: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BlocksP1', 'p1', p1)
            const localVarPath = `/api/v1/blocks/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a stream of block summaries ordered by global index (height)
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BlocksStreamSummary: async (offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/blocks/stream/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByaddressP1: async (p1: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesByaddressP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/byAddress/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByergotreeP1: async (p1: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesByergotreeP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/byErgoTree/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByergotreetemplatehashP1: async (p1: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesByergotreetemplatehashP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/byErgoTreeTemplateHash/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a stream of unspent outputs by a hash of the given ErgoTreeTemplate
         * @param {string} p1
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByergotreetemplatehashP1Stream: async (p1: string, minHeight: number, maxHeight: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesByergotreetemplatehashP1Stream', 'p1', p1)
            // verify required parameter 'minHeight' is not null or undefined
            assertParamExists('getApiV1BoxesByergotreetemplatehashP1Stream', 'minHeight', minHeight)
            // verify required parameter 'maxHeight' is not null or undefined
            assertParamExists('getApiV1BoxesByergotreetemplatehashP1Stream', 'maxHeight', maxHeight)
            const localVarPath = `/api/v1/boxes/byErgoTreeTemplateHash/{p1}/stream`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a stream of outputs ordered by global index
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByglobalindexStream: async (minGix: number, limit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'minGix' is not null or undefined
            assertParamExists('getApiV1BoxesByglobalindexStream', 'minGix', minGix)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getApiV1BoxesByglobalindexStream', 'limit', limit)
            const localVarPath = `/api/v1/boxes/byGlobalIndex/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minGix !== undefined) {
                localVarQueryParameter['minGix'] = minGix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesBytokenidP1: async (p1: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesBytokenidP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/byTokenId/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesP1: async (p1: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByaddressP1: async (p1: string, offset?: number, limit?: number, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentByaddressP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/unspent/byAddress/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByergotreeP1: async (p1: string, offset?: number, limit?: number, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentByergotreeP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/unspent/byErgoTree/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByergotreetemplatehashP1: async (p1: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentByergotreetemplatehashP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/unspent/byErgoTreeTemplateHash/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByergotreetemplatehashP1Stream: async (p1: string, minHeight: number, maxHeight: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentByergotreetemplatehashP1Stream', 'p1', p1)
            // verify required parameter 'minHeight' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentByergotreetemplatehashP1Stream', 'minHeight', minHeight)
            // verify required parameter 'maxHeight' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentByergotreetemplatehashP1Stream', 'maxHeight', maxHeight)
            const localVarPath = `/api/v1/boxes/unspent/byErgoTreeTemplateHash/{p1}/stream`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a stream of unspent outputs ordered by global index
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByglobalindexStream: async (minGix: number, limit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'minGix' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentByglobalindexStream', 'minGix', minGix)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentByglobalindexStream', 'limit', limit)
            const localVarPath = `/api/v1/boxes/unspent/byGlobalIndex/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minGix !== undefined) {
                localVarQueryParameter['minGix'] = minGix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} lastEpochs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentBylastepochsStream: async (lastEpochs: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lastEpochs' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentBylastepochsStream', 'lastEpochs', lastEpochs)
            const localVarPath = `/api/v1/boxes/unspent/byLastEpochs/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lastEpochs !== undefined) {
                localVarQueryParameter['lastEpochs'] = lastEpochs;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentBytokenidP1: async (p1: string, offset?: number, limit?: number, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentBytokenidP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/unspent/byTokenId/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentStream: async (minHeight: number, maxHeight: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'minHeight' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentStream', 'minHeight', minHeight)
            // verify required parameter 'maxHeight' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentStream', 'maxHeight', maxHeight)
            const localVarPath = `/api/v1/boxes/unspent/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentUnconfirmedByaddressP1: async (p1: string, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1BoxesUnspentUnconfirmedByaddressP1', 'p1', p1)
            const localVarPath = `/api/v1/boxes/unspent/unconfirmed/byAddress/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1EpochsParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/epochs/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getApiV1Info: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a stream of unspent outputs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1MempoolBoxesUnspent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/mempool/boxes/unspent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1MempoolTransactionsByaddressP1: async (p1: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1MempoolTransactionsByaddressP1', 'p1', p1)
            const localVarPath = `/api/v1/mempool/transactions/byAddress/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1Networkstate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/networkState`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1Networkstats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/networkStats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {boolean} [hideNfts] Exclude NFTs from result set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1Tokens: async (offset?: number, limit?: number, sortDirection?: string, hideNfts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (hideNfts !== undefined) {
                localVarQueryParameter['hideNfts'] = hideNfts;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all assets with a given Symbol. Note that symbols aren\'t unique.
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TokensBysymbolP1: async (p1: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1TokensBysymbolP1', 'p1', p1)
            const localVarPath = `/api/v1/tokens/bySymbol/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TokensP1: async (p1: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1TokensP1', 'p1', p1)
            const localVarPath = `/api/v1/tokens/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search by ID or Symbol of an asset. Note that symbols aren\'t unique.
         * @param {string} query
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TokensSearch: async (query: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getApiV1TokensSearch', 'query', query)
            const localVarPath = `/api/v1/tokens/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a stream of transactions ordered by global index
         * @param {number} minGix Min global index (in blockchain) of the TX
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TransactionsByglobalindexStream: async (minGix: number, limit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'minGix' is not null or undefined
            assertParamExists('getApiV1TransactionsByglobalindexStream', 'minGix', minGix)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getApiV1TransactionsByglobalindexStream', 'limit', limit)
            const localVarPath = `/api/v1/transactions/byGlobalIndex/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minGix !== undefined) {
                localVarQueryParameter['minGix'] = minGix;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TransactionsByinputsscripttemplatehashP1: async (p1: string, offset?: number, limit?: number, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1TransactionsByinputsscripttemplatehashP1', 'p1', p1)
            const localVarPath = `/api/v1/transactions/byInputsScriptTemplateHash/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TransactionsP1: async (p1: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'p1' is not null or undefined
            assertParamExists('getApiV1TransactionsP1', 'p1', p1)
            const localVarPath = `/api/v1/transactions/{p1}`
                .replace(`{${"p1"}}`, encodeURIComponent(String(p1)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detailed search among all boxes in the chain
         * @param {BoxQuery} boxQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1BoxesSearch: async (boxQuery: BoxQuery, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boxQuery' is not null or undefined
            assertParamExists('postApiV1BoxesSearch', 'boxQuery', boxQuery)
            const localVarPath = `/api/v1/boxes/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boxQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detailed search among UTXO set
         * @param {BoxQuery} boxQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1BoxesUnspentSearch: async (boxQuery: BoxQuery, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boxQuery' is not null or undefined
            assertParamExists('postApiV1BoxesUnspentSearch', 'boxQuery', boxQuery)
            const localVarPath = `/api/v1/boxes/unspent/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boxQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search among UTXO set by ergoTreeTemplateHash and tokens. The resulted UTXOs will contain at lest one of the given tokens.
         * @param {BoxAssetsQuery} boxAssetsQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1BoxesUnspentSearchUnion: async (boxAssetsQuery: BoxAssetsQuery, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boxAssetsQuery' is not null or undefined
            assertParamExists('postApiV1BoxesUnspentSearchUnion', 'boxAssetsQuery', boxAssetsQuery)
            const localVarPath = `/api/v1/boxes/unspent/search/union`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boxAssetsQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {ErgoTreeConversionRequest} ergoTreeConversionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1ErgotreeConvert: async (ergoTreeConversionRequest: ErgoTreeConversionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ergoTreeConversionRequest' is not null or undefined
            assertParamExists('postApiV1ErgotreeConvert', 'ergoTreeConversionRequest', ergoTreeConversionRequest)
            const localVarPath = `/api/v1/ergotree/convert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ergoTreeConversionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1MempoolTransactionsSubmit: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postApiV1MempoolTransactionsSubmit', 'body', body)
            const localVarPath = `/api/v1/mempool/transactions/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} p1
         * @param {number} [minConfirmations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1AddressesP1BalanceConfirmed(p1: string, minConfirmations?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1AddressesP1BalanceConfirmed(p1, minConfirmations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1AddressesP1BalanceTotal(p1: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TotalBalance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1AddressesP1BalanceTotal(p1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [concise] Display only address inputs/outputs in transaction
         * @param {number} [fromHeight]
         * @param {number} [toHeight]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1AddressesP1Transactions(p1: string, offset?: number, limit?: number, concise?: boolean, fromHeight?: number, toHeight?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1AddressesP1Transactions(p1, offset, limit, concise, fromHeight, toHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use \'/tokens\' instead
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {boolean} [hideNfts] Exclude NFTs from result set
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getApiV1Assets(offset?: number, limit?: number, sortDirection?: string, hideNfts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1Assets(offset, limit, sortDirection, hideNfts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} query
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1AssetsSearchBytokenid(query: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1AssetsSearchBytokenid(query, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1Blocks(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlocksInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1Blocks(offset, limit, sortBy, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a stream of blocks ordered by global index (height)
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BlocksByglobalindexStream(minGix: number, limit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBlockInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BlocksByglobalindexStream(minGix, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BlocksHeaders(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BlocksHeaders(offset, limit, sortBy, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BlocksP1(p1: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BlocksP1(p1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a stream of block summaries ordered by global index (height)
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BlocksStreamSummary(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBlockSummaryV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BlocksStreamSummary(offset, limit, sortBy, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesByaddressP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesByaddressP1(p1, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesByergotreeP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesByergotreeP1(p1, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesByergotreetemplatehashP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesByergotreetemplatehashP1(p1, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a stream of unspent outputs by a hash of the given ErgoTreeTemplate
         * @param {string} p1
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesByergotreetemplatehashP1Stream(p1: string, minHeight: number, maxHeight: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOutputInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesByergotreetemplatehashP1Stream(p1, minHeight, maxHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a stream of outputs ordered by global index
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesByglobalindexStream(minGix: number, limit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOutputInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesByglobalindexStream(minGix, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesBytokenidP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesBytokenidP1(p1, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesP1(p1: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutputInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesP1(p1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentByaddressP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsB>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentByaddressP1(p1, offset, limit, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentByergotreeP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentByergotreeP1(p1, offset, limit, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentByergotreetemplatehashP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentByergotreetemplatehashP1(p1, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentByergotreetemplatehashP1Stream(p1: string, minHeight: number, maxHeight: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOutputInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentByergotreetemplatehashP1Stream(p1, minHeight, maxHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a stream of unspent outputs ordered by global index
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentByglobalindexStream(minGix: number, limit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOutputInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentByglobalindexStream(minGix, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} lastEpochs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentBylastepochsStream(lastEpochs: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOutputInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentBylastepochsStream(lastEpochs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentBytokenidP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsB>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentBytokenidP1(p1, offset, limit, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentStream(minHeight: number, maxHeight: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOutputInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentStream(minHeight, maxHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1BoxesUnspentUnconfirmedByaddressP1(p1: string, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MOutputInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1BoxesUnspentUnconfirmedByaddressP1(p1, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1EpochsParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpochInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1EpochsParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getApiV1Info(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1Info(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a stream of unspent outputs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1MempoolBoxesUnspent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOutputInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1MempoolBoxesUnspent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1MempoolTransactionsByaddressP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1MempoolTransactionsByaddressP1(p1, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1Networkstate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1Networkstate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1Networkstats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1Networkstats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {boolean} [hideNfts] Exclude NFTs from result set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1Tokens(offset?: number, limit?: number, sortDirection?: string, hideNfts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1Tokens(offset, limit, sortDirection, hideNfts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all assets with a given Symbol. Note that symbols aren\'t unique.
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1TokensBysymbolP1(p1: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1TokensBysymbolP1(p1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1TokensP1(p1: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1TokensP1(p1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search by ID or Symbol of an asset. Note that symbols aren\'t unique.
         * @param {string} query
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1TokensSearch(query: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1TokensSearch(query, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a stream of transactions ordered by global index
         * @param {number} minGix Min global index (in blockchain) of the TX
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1TransactionsByglobalindexStream(minGix: number, limit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1TransactionsByglobalindexStream(minGix, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1TransactionsByinputsscripttemplatehashP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1TransactionsByinputsscripttemplatehashP1(p1, offset, limit, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiV1TransactionsP1(p1: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiV1TransactionsP1(p1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detailed search among all boxes in the chain
         * @param {BoxQuery} boxQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiV1BoxesSearch(boxQuery: BoxQuery, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiV1BoxesSearch(boxQuery, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detailed search among UTXO set
         * @param {BoxQuery} boxQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiV1BoxesUnspentSearch(boxQuery: BoxQuery, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiV1BoxesUnspentSearch(boxQuery, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search among UTXO set by ergoTreeTemplateHash and tokens. The resulted UTXOs will contain at lest one of the given tokens.
         * @param {BoxAssetsQuery} boxAssetsQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiV1BoxesUnspentSearchUnion(boxAssetsQuery: BoxAssetsQuery, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiV1BoxesUnspentSearchUnion(boxAssetsQuery, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {ErgoTreeConversionRequest} ergoTreeConversionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiV1ErgotreeConvert(ergoTreeConversionRequest: ErgoTreeConversionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErgoTreeHuman>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiV1ErgotreeConvert(ergoTreeConversionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiV1MempoolTransactionsSubmit(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiV1MempoolTransactionsSubmit(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         *
         * @param {string} p1
         * @param {number} [minConfirmations]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1AddressesP1BalanceConfirmed(p1: string, minConfirmations?: number, options?: any): AxiosPromise<Balance> {
            return localVarFp.getApiV1AddressesP1BalanceConfirmed(p1, minConfirmations, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1AddressesP1BalanceTotal(p1: string, options?: any): AxiosPromise<TotalBalance> {
            return localVarFp.getApiV1AddressesP1BalanceTotal(p1, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [concise] Display only address inputs/outputs in transaction
         * @param {number} [fromHeight]
         * @param {number} [toHeight]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1AddressesP1Transactions(p1: string, offset?: number, limit?: number, concise?: boolean, fromHeight?: number, toHeight?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1AddressesP1Transactions(p1, offset, limit, concise, fromHeight, toHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * Use \'/tokens\' instead
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {boolean} [hideNfts] Exclude NFTs from result set
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getApiV1Assets(offset?: number, limit?: number, sortDirection?: string, hideNfts?: boolean, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1Assets(offset, limit, sortDirection, hideNfts, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} query
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1AssetsSearchBytokenid(query: string, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1AssetsSearchBytokenid(query, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1Blocks(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: any): AxiosPromise<BlocksInfo> {
            return localVarFp.getApiV1Blocks(offset, limit, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a stream of blocks ordered by global index (height)
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BlocksByglobalindexStream(minGix: number, limit: number, options?: any): AxiosPromise<ListBlockInfo> {
            return localVarFp.getApiV1BlocksByglobalindexStream(minGix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BlocksHeaders(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1BlocksHeaders(offset, limit, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BlocksP1(p1: string, options?: any): AxiosPromise<BlockSummary> {
            return localVarFp.getApiV1BlocksP1(p1, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a stream of block summaries ordered by global index (height)
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortBy]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BlocksStreamSummary(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: any): AxiosPromise<ListBlockSummaryV1> {
            return localVarFp.getApiV1BlocksStreamSummary(offset, limit, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByaddressP1(p1: string, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1BoxesByaddressP1(p1, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByergotreeP1(p1: string, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1BoxesByergotreeP1(p1, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByergotreetemplatehashP1(p1: string, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1BoxesByergotreetemplatehashP1(p1, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a stream of unspent outputs by a hash of the given ErgoTreeTemplate
         * @param {string} p1
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByergotreetemplatehashP1Stream(p1: string, minHeight: number, maxHeight: number, options?: any): AxiosPromise<ListOutputInfo> {
            return localVarFp.getApiV1BoxesByergotreetemplatehashP1Stream(p1, minHeight, maxHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a stream of outputs ordered by global index
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesByglobalindexStream(minGix: number, limit: number, options?: any): AxiosPromise<ListOutputInfo> {
            return localVarFp.getApiV1BoxesByglobalindexStream(minGix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesBytokenidP1(p1: string, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1BoxesBytokenidP1(p1, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesP1(p1: string, options?: any): AxiosPromise<OutputInfo> {
            return localVarFp.getApiV1BoxesP1(p1, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByaddressP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: any): AxiosPromise<ItemsB> {
            return localVarFp.getApiV1BoxesUnspentByaddressP1(p1, offset, limit, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByergotreeP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1BoxesUnspentByergotreeP1(p1, offset, limit, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByergotreetemplatehashP1(p1: string, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1BoxesUnspentByergotreetemplatehashP1(p1, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByergotreetemplatehashP1Stream(p1: string, minHeight: number, maxHeight: number, options?: any): AxiosPromise<ListOutputInfo> {
            return localVarFp.getApiV1BoxesUnspentByergotreetemplatehashP1Stream(p1, minHeight, maxHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a stream of unspent outputs ordered by global index
         * @param {number} minGix Min global index (in blockchain) of an on-chain entity
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentByglobalindexStream(minGix: number, limit: number, options?: any): AxiosPromise<ListOutputInfo> {
            return localVarFp.getApiV1BoxesUnspentByglobalindexStream(minGix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} lastEpochs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentBylastepochsStream(lastEpochs: number, options?: any): AxiosPromise<ListOutputInfo> {
            return localVarFp.getApiV1BoxesUnspentBylastepochsStream(lastEpochs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentBytokenidP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: any): AxiosPromise<ItemsB> {
            return localVarFp.getApiV1BoxesUnspentBytokenidP1(p1, offset, limit, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} minHeight
         * @param {number} maxHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentStream(minHeight: number, maxHeight: number, options?: any): AxiosPromise<ListOutputInfo> {
            return localVarFp.getApiV1BoxesUnspentStream(minHeight, maxHeight, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1BoxesUnspentUnconfirmedByaddressP1(p1: string, sortDirection?: string, options?: any): AxiosPromise<Array<MOutputInfo>> {
            return localVarFp.getApiV1BoxesUnspentUnconfirmedByaddressP1(p1, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1EpochsParams(options?: any): AxiosPromise<EpochInfo> {
            return localVarFp.getApiV1EpochsParams(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getApiV1Info(options?: any): AxiosPromise<NetworkState> {
            return localVarFp.getApiV1Info(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a stream of unspent outputs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1MempoolBoxesUnspent(options?: any): AxiosPromise<ListOutputInfo> {
            return localVarFp.getApiV1MempoolBoxesUnspent(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1MempoolTransactionsByaddressP1(p1: string, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1MempoolTransactionsByaddressP1(p1, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1Networkstate(options?: any): AxiosPromise<NetworkState> {
            return localVarFp.getApiV1Networkstate(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1Networkstats(options?: any): AxiosPromise<NetworkStats> {
            return localVarFp.getApiV1Networkstats(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {boolean} [hideNfts] Exclude NFTs from result set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1Tokens(offset?: number, limit?: number, sortDirection?: string, hideNfts?: boolean, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1Tokens(offset, limit, sortDirection, hideNfts, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all assets with a given Symbol. Note that symbols aren\'t unique.
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TokensBysymbolP1(p1: string, options?: any): AxiosPromise<Array<TokenInfo>> {
            return localVarFp.getApiV1TokensBysymbolP1(p1, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TokensP1(p1: string, options?: any): AxiosPromise<TokenInfo> {
            return localVarFp.getApiV1TokensP1(p1, options).then((request) => request(axios, basePath));
        },
        /**
         * Search by ID or Symbol of an asset. Note that symbols aren\'t unique.
         * @param {string} query
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TokensSearch(query: string, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1TokensSearch(query, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a stream of transactions ordered by global index
         * @param {number} minGix Min global index (in blockchain) of the TX
         * @param {number} limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TransactionsByglobalindexStream(minGix: number, limit: number, options?: any): AxiosPromise<ListTransactionInfo> {
            return localVarFp.getApiV1TransactionsByglobalindexStream(minGix, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [sortDirection]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TransactionsByinputsscripttemplatehashP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.getApiV1TransactionsByinputsscripttemplatehashP1(p1, offset, limit, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} p1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiV1TransactionsP1(p1: string, options?: any): AxiosPromise<TransactionInfo> {
            return localVarFp.getApiV1TransactionsP1(p1, options).then((request) => request(axios, basePath));
        },
        /**
         * Detailed search among all boxes in the chain
         * @param {BoxQuery} boxQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1BoxesSearch(boxQuery: BoxQuery, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.postApiV1BoxesSearch(boxQuery, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Detailed search among UTXO set
         * @param {BoxQuery} boxQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1BoxesUnspentSearch(boxQuery: BoxQuery, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.postApiV1BoxesUnspentSearch(boxQuery, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Search among UTXO set by ergoTreeTemplateHash and tokens. The resulted UTXOs will contain at lest one of the given tokens.
         * @param {BoxAssetsQuery} boxAssetsQuery
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1BoxesUnspentSearchUnion(boxAssetsQuery: BoxAssetsQuery, offset?: number, limit?: number, options?: any): AxiosPromise<ItemsA> {
            return localVarFp.postApiV1BoxesUnspentSearchUnion(boxAssetsQuery, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ErgoTreeConversionRequest} ergoTreeConversionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1ErgotreeConvert(ergoTreeConversionRequest: ErgoTreeConversionRequest, options?: any): AxiosPromise<ErgoTreeHuman> {
            return localVarFp.postApiV1ErgotreeConvert(ergoTreeConversionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {object} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiV1MempoolTransactionsSubmit(body: object, options?: any): AxiosPromise<TxIdResponse> {
            return localVarFp.postApiV1MempoolTransactionsSubmit(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @param {string} p1
     * @param {number} [minConfirmations]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1AddressesP1BalanceConfirmed(p1: string, minConfirmations?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1AddressesP1BalanceConfirmed(p1, minConfirmations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1AddressesP1BalanceTotal(p1: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1AddressesP1BalanceTotal(p1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {boolean} [concise] Display only address inputs/outputs in transaction
     * @param {number} [fromHeight]
     * @param {number} [toHeight]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1AddressesP1Transactions(p1: string, offset?: number, limit?: number, concise?: boolean, fromHeight?: number, toHeight?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1AddressesP1Transactions(p1, offset, limit, concise, fromHeight, toHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use \'/tokens\' instead
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortDirection]
     * @param {boolean} [hideNfts] Exclude NFTs from result set
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1Assets(offset?: number, limit?: number, sortDirection?: string, hideNfts?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1Assets(offset, limit, sortDirection, hideNfts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} query
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1AssetsSearchBytokenid(query: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1AssetsSearchBytokenid(query, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1Blocks(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1Blocks(offset, limit, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a stream of blocks ordered by global index (height)
     * @param {number} minGix Min global index (in blockchain) of an on-chain entity
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BlocksByglobalindexStream(minGix: number, limit: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BlocksByglobalindexStream(minGix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BlocksHeaders(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BlocksHeaders(offset, limit, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BlocksP1(p1: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BlocksP1(p1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a stream of block summaries ordered by global index (height)
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BlocksStreamSummary(offset?: number, limit?: number, sortBy?: string, sortDirection?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BlocksStreamSummary(offset, limit, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesByaddressP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesByaddressP1(p1, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesByergotreeP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesByergotreeP1(p1, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesByergotreetemplatehashP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesByergotreetemplatehashP1(p1, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a stream of unspent outputs by a hash of the given ErgoTreeTemplate
     * @param {string} p1
     * @param {number} minHeight
     * @param {number} maxHeight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesByergotreetemplatehashP1Stream(p1: string, minHeight: number, maxHeight: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesByergotreetemplatehashP1Stream(p1, minHeight, maxHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a stream of outputs ordered by global index
     * @param {number} minGix Min global index (in blockchain) of an on-chain entity
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesByglobalindexStream(minGix: number, limit: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesByglobalindexStream(minGix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesBytokenidP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesBytokenidP1(p1, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesP1(p1: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesP1(p1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentByaddressP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentByaddressP1(p1, offset, limit, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentByergotreeP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentByergotreeP1(p1, offset, limit, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentByergotreetemplatehashP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentByergotreetemplatehashP1(p1, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} minHeight
     * @param {number} maxHeight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentByergotreetemplatehashP1Stream(p1: string, minHeight: number, maxHeight: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentByergotreetemplatehashP1Stream(p1, minHeight, maxHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a stream of unspent outputs ordered by global index
     * @param {number} minGix Min global index (in blockchain) of an on-chain entity
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentByglobalindexStream(minGix: number, limit: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentByglobalindexStream(minGix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} lastEpochs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentBylastepochsStream(lastEpochs: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentBylastepochsStream(lastEpochs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentBytokenidP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentBytokenidP1(p1, offset, limit, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} minHeight
     * @param {number} maxHeight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentStream(minHeight: number, maxHeight: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentStream(minHeight, maxHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1BoxesUnspentUnconfirmedByaddressP1(p1: string, sortDirection?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1BoxesUnspentUnconfirmedByaddressP1(p1, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1EpochsParams(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1EpochsParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1Info(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1Info(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a stream of unspent outputs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1MempoolBoxesUnspent(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1MempoolBoxesUnspent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1MempoolTransactionsByaddressP1(p1: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1MempoolTransactionsByaddressP1(p1, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1Networkstate(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1Networkstate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1Networkstats(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1Networkstats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortDirection]
     * @param {boolean} [hideNfts] Exclude NFTs from result set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1Tokens(offset?: number, limit?: number, sortDirection?: string, hideNfts?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1Tokens(offset, limit, sortDirection, hideNfts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all assets with a given Symbol. Note that symbols aren\'t unique.
     * @param {string} p1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1TokensBysymbolP1(p1: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1TokensBysymbolP1(p1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1TokensP1(p1: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1TokensP1(p1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search by ID or Symbol of an asset. Note that symbols aren\'t unique.
     * @param {string} query
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1TokensSearch(query: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1TokensSearch(query, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a stream of transactions ordered by global index
     * @param {number} minGix Min global index (in blockchain) of the TX
     * @param {number} limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1TransactionsByglobalindexStream(minGix: number, limit: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1TransactionsByglobalindexStream(minGix, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1TransactionsByinputsscripttemplatehashP1(p1: string, offset?: number, limit?: number, sortDirection?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1TransactionsByinputsscripttemplatehashP1(p1, offset, limit, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} p1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiV1TransactionsP1(p1: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiV1TransactionsP1(p1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detailed search among all boxes in the chain
     * @param {BoxQuery} boxQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postApiV1BoxesSearch(boxQuery: BoxQuery, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postApiV1BoxesSearch(boxQuery, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detailed search among UTXO set
     * @param {BoxQuery} boxQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postApiV1BoxesUnspentSearch(boxQuery: BoxQuery, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postApiV1BoxesUnspentSearch(boxQuery, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search among UTXO set by ergoTreeTemplateHash and tokens. The resulted UTXOs will contain at lest one of the given tokens.
     * @param {BoxAssetsQuery} boxAssetsQuery
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postApiV1BoxesUnspentSearchUnion(boxAssetsQuery: BoxAssetsQuery, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postApiV1BoxesUnspentSearchUnion(boxAssetsQuery, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {ErgoTreeConversionRequest} ergoTreeConversionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postApiV1ErgotreeConvert(ergoTreeConversionRequest: ErgoTreeConversionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postApiV1ErgotreeConvert(ergoTreeConversionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postApiV1MempoolTransactionsSubmit(body: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postApiV1MempoolTransactionsSubmit(body, options).then((request) => request(this.axios, this.basePath));
    }
}